<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Anti Drowsiness</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: black;
        font-family: Arial, sans-serif;
        color: white;
      }

      /* SMS Setup Styles */
      .sms-setup-container {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100%;
        padding: 20px;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        background: black;
        z-index: 50;
      }

      .sms-setup-container h2 {
        margin-bottom: 30px;
        font-size: 24px;
        color: white;
      }

      .sms-setup-container input {
        width: 100%;
        max-width: 300px;
        padding: 12px;
        margin: 10px 0;
        border: 1px solid #444;
        border-radius: 8px;
        background-color: #1c1c1c;
        color: white;
        font-size: 16px;
      }

      .sms-setup-container input::placeholder {
        color: #aaa;
      }

      .sms-setup-container button {
        width: 100%;
        max-width: 300px;
        padding: 12px;
        background-color: #2196f3;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        margin-top: 20px;
        transition: background-color 0.3s;
      }

      .sms-setup-container button:hover,
      .sms-setup-container button:active {
        background-color: #0b7dda;
      }

      /* Main App Styles */
      .container {
        position: relative;
        width: 100%;
        height: 100%;
      }

      video,
      canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #status {
        position: absolute;
        top: 10px;
        left: 0;
        right: 0;
        text-align: center;
        padding: 10px;
        font-size: 24px;
        font-weight: bold;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        z-index: 10;
      }

      #alert {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 0, 0, 0.3);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 5;
      }

      #alert-text {
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 20px;
        border-radius: 10px;
        font-size: 30px;
        font-weight: bold;
      }

      #debug {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 5px;
        font-size: 14px;
        border-radius: 5px;
        z-index: 10;
      }

      #notification {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.5s;
      }

      #phone-container {
        position: absolute;
        top: 50px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        z-index: 10;
      }

      /* Permission overlay */
      #permission-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 20;
        color: white;
        text-align: center;
        padding: 20px;
        box-sizing: border-box;
      }

      #start-button {
        margin-top: 20px;
        padding: 15px 30px;
        background-color: #2196f3;
        color: white;
        border: none;
        border-radius: 5px;
        font-size: 18px;
        cursor: pointer;
        transition: background-color 0.3s;
        -webkit-tap-highlight-color: transparent;
      }

      #start-button:hover,
      #start-button:active {
        background-color: #0b7dda;
      }

      .permission-text {
        max-width: 90%;
        margin-bottom: 20px;
        font-size: 16px;
        line-height: 1.5;
      }

      /* Android specific error message */
      #android-error {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 30;
        color: white;
        text-align: center;
        padding: 20px;
        box-sizing: border-box;
      }
    </style>
  </head>
  <body>
    <!-- SMS Setup Screen -->
    <div class="sms-setup-container" id="sms-setup">
      <h2>Enter Phone Number</h2>
      <input
        type="text"
        id="countryCode"
        placeholder="Country Code (e.g. +66)"
      />
      <input
        type="text"
        id="phoneNumber"
        placeholder="Phone Number (e.g. 812345678)"
      />
      <button onclick="saveNumber()">Save & Continue</button>
    </div>

    <!-- Main App -->
    <div class="container" id="main-app">
      <!-- Permission overlay -->
      <div id="permission-overlay">
        <h2>Drowsiness Detection System</h2>
        <div class="permission-text">
          <p>
            This application uses your camera to detect drowsiness and can send
            alert messages when dangerous drowsiness is detected.
          </p>
          <p>
            We need your permission to access your camera for this safety
            feature to work.
          </p>
          <p>
            No video data is stored or transmitted - all processing happens
            locally in your browser.
          </p>
        </div>
        <button id="start-button">Start Camera & Begin Monitoring</button>
      </div>

      <!-- Android specific error message -->
      <div id="android-error">
        <h2>Camera Access Error</h2>
        <div class="permission-text">
          <p>Unable to access the camera. This may be due to:</p>
          <p>1. Camera permission not granted in Android settings</p>
          <p>2. Another app is currently using the camera</p>
          <p>3. WebView camera access is not enabled in the app</p>
        </div>
        <button id="retry-button">Retry Camera Access</button>
      </div>

      <video id="video" autoplay muted playsinline></video>
      <canvas id="output"></canvas>
      <div id="status">Waiting for camera permission...</div>
      <div id="alert"><div id="alert-text">EYES CLOSED TOO LONG!</div></div>
      <div id="debug">EAR: 0.00 | FPS: 0 | State: Not Started</div>
      <div id="notification">SMS Alert: Inactive</div>
      <div id="phone-container">Alert Phone: Default</div>
    </div>

    <audio id="alertSound" src="alert.mp3"></audio>

    <script>
      // Check if phone number is already set
      document.addEventListener("DOMContentLoaded", function() {
        const savedNumber = localStorage.getItem("alertPhoneNumber");
        if (savedNumber) {
          // If phone number exists, hide SMS setup and show main app
          document.getElementById("sms-setup").style.display = "none";
        } else {
          // If no phone number, keep SMS setup visible and hide main app
          document.getElementById("main-app").style.opacity = "0.3";
        }
      });

      // SMS Setup Function
      function saveNumber() {
        const countryCode = document.getElementById("countryCode").value.trim();
        const phoneNumber = document.getElementById("phoneNumber").value.trim();

        if (!countryCode.startsWith("+") || phoneNumber.length < 6) {
          alert("Please enter a valid country code and phone number.");
          return;
        }

        const fullNumber = countryCode + phoneNumber;
        localStorage.setItem("alertPhoneNumber", fullNumber);
        
        // Hide SMS setup and show main app
        document.getElementById("sms-setup").style.display = "none";
        document.getElementById("main-app").style.opacity = "1";
        
        // Update phone container with the new number
        document.getElementById("phone-container").textContent = "Alert Phone: " + fullNumber;
        
        // Show notification
        showNotification("Phone number set: " + fullNumber);
      }

      // Main App Script
      let port;
      let writer;

      async function connectSerial() {
        try {
          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });

          const encoder = new TextEncoderStream();
          encoder.readable.pipeTo(port.writable);
          writer = encoder.writable.getWriter();

          alert("Connected to ESP32");
        } catch (err) {
          // alert("Connection failed: " + err);
        }
      }

      async function sendVibration() {
        await writer.write("vibrate:5\n");
      }
      // Flag to track if running from MIT App Inventor

      // Function to be called from MIT App Inventor to indicate the environment
      function runfrommit() {
        isRunningFromMIT = true;
        console.log("Running from MIT App Inventor environment");
        showNotification("MIT App Inventor detected");

        // Automatically initialize camera when running from MIT
        if (androidBridge.hasAndroidBridge) {
          // If we have Android bridge, we need to check permissions
          checkAndroidPermissions().then((permissionsOK) => {
            if (permissionsOK) {
              initCamera();
            }
          });
        } else {
          // No Android bridge, directly initialize camera
          initCamera();
        }

        // Send acknowledgment to App Inventor if WebViewString is available
        if (window.AppInventor && window.AppInventor.setWebViewString) {
          window.AppInventor.setWebViewString("MIT_ENVIRONMENT=ACKNOWLEDGED");
        }

        return true; // Return true to confirm successful execution
      }

      // Make runfrommit globally available
      window.runfrommit = runfrommit;

      // Android WebView Bridge
      function AndroidBridge() {
        this.hasAndroidBridge = typeof Android !== "undefined";

        this.requestCameraPermission = function () {
          if (this.hasAndroidBridge && Android.requestCameraPermission) {
            return Android.requestCameraPermission();
          }
          return true; // Return true if no Android bridge (regular browser)
        };

        this.hasCameraPermission = function () {
          if (this.hasAndroidBridge && Android.hasCameraPermission) {
            return Android.hasCameraPermission();
          }
          return true; // Return true if no Android bridge (regular browser)
        };

        this.showToast = function (message) {
          if (this.hasAndroidBridge && Android.showToast) {
            Android.showToast(message);
          } else {
            console.log("Toast (not on Android):", message);
          }
        };
      }

      const androidBridge = new AndroidBridge();

      // Elements
      const video = document.getElementById("video");
      const canvas = document.getElementById("output");
      const ctx = canvas.getContext("2d");
      const status = document.getElementById("status");
      const alertBox = document.getElementById("alert");
      const alertSound = document.getElementById("alertSound");
      const debug = document.getElementById("debug");
      const notification = document.getElementById("notification");
      const phoneContainer = document.getElementById("phone-container");
      const permissionOverlay = document.getElementById("permission-overlay");
      const startButton = document.getElementById("start-button");
      const androidError = document.getElementById("android-error");
      const retryButton = document.getElementById("retry-button");

      // Adjusted threshold for more accurate eye closure detection
      const EAR_THRESHOLD = 0.2; // Threshold for eye closure
      const TARGET_ALERT_TIME = 3; // Alert after 3 seconds of eyes closed
      const RECOVERY_FRAMES = 3; // Number of open frames needed to reset alert
      const SMS_COOLDOWN_TIME = 15000; // 15 seconds cooldown for SMS alerts
      const savedNumber = localStorage.getItem("alertPhoneNumber");
      console.log("SMS will be sent to:", savedNumber);

      // SMS Configuration using API key instead of Account SID/Auth Token
      const twilioApiKey = "SK361e6faad3ec68d3c14e0b925c3dde47";
      const twilioApiSecret = "oAZyaPgsFF7oEzbVT1hRktGuiIu9wWL1";
      const twilioAccountSid = "AC7de93db1c7917508d40746d5c34a0f1e"; // Still need account SID for URL
      const twilioFromNumber = "+18166246916";
      let alertPhoneNumber = savedNumber; // Default phone number
      const alertMessage = "Drowsy Detect SMS Direct to this number";

      // Track last SMS sent time
      let lastSMSSentTime = 0;
      let camera = null;

      // Function to receive phone number from external source
      function receivePhoneNumber(phoneNumber) {
        console.log("Received phone number: " + phoneNumber);
        // Update the alert phone number
        alertPhoneNumber = phoneNumber;
        // Display it in the UI
        phoneContainer.textContent = "Alert Phone: " + phoneNumber;
        // Show notification
        showNotification("Alert phone number updated: " + phoneNumber);

        // Show toast on Android if available
        androidBridge.showToast("Alert phone updated: " + phoneNumber);
      }

      // Make the function globally available
      window.receivePhoneNumber = receivePhoneNumber;

      // FPS calculation
      let frameTimestamps = [];
      let currentFPS = 0;
      let framesForThreeSeconds = 30; // Initial guess, will be adjusted based on actual FPS

      let consecutiveClosedFrames = 0;
      let consecutiveOpenFrames = 0;
      let isAlertActive = false;
      let earHistory = [];
      const EAR_HISTORY_SIZE = 30; // Track EAR values to establish baseline

      const appInventorBridge = {
        sendAlert: function (isActive) {
          if (window.AppInventor && window.AppInventor.setWebViewString) {
            window.AppInventor.setWebViewString(
              "ALERT_STATE=" + (isActive ? "ACTIVE" : "INACTIVE")
            );
          }
        },
      };

      // Function to send SMS alert with Twilio using API keys
      function sendSMSAlert() {
        const currentTime = Date.now();

        // Check cooldown period
        if (currentTime - lastSMSSentTime < SMS_COOLDOWN_TIME) {
          const remainingCooldown = Math.ceil(
            (SMS_COOLDOWN_TIME - (currentTime - lastSMSSentTime)) / 1000
          );
          showNotification(`SMS cooldown: ${remainingCooldown}s remaining`);
          return;
        }

        // Update last sent time
        lastSMSSentTime = currentTime;

        showNotification(`Sending SMS alert to ${alertPhoneNumber}...`);

        // Android toast if available
        androidBridge.showToast("Sending SMS alert...");

        // Prepare data for the POST request
        const url = `https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`;
        const data = new URLSearchParams();
        data.append("From", twilioFromNumber);
        data.append("To", alertPhoneNumber);
        data.append("Body", alertMessage);

        // Send the POST request to Twilio API with API Key authentication
        fetch(url, {
          method: "POST",
          body: data,
          headers: {
            Authorization:
              "Basic " + btoa(twilioApiKey + ":" + twilioApiSecret),
            "Content-Type": "application/x-www-form-urlencoded",
          },
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error_code) {
              showNotification(`SMS Error: ${data.message}`);
              console.error("Error sending SMS:", data.message);
              androidBridge.showToast("SMS Error: " + data.message);
            } else {
              showNotification("SMS alert sent successfully!");
              console.log("SMS sent successfully:", data.sid);
              androidBridge.showToast("SMS alert sent successfully!");
            }
          })
          .catch((error) => {
            showNotification("Failed to send SMS alert");
            console.error("Error sending SMS:", error);
            androidBridge.showToast("Failed to send SMS alert");
          });
      }

      // Show notification with auto-hide
      function showNotification(message) {
        notification.textContent = message;
        notification.style.opacity = 1;

        // Hide notification after 3 seconds
        setTimeout(() => {
          notification.style.opacity = 0;
        }, 3000);
      }

      // Calculate FPS based on recent frame timestamps
      function updateFPS() {
        const now = performance.now();
        frameTimestamps.push(now);

        // Keep only the last 30 frames for FPS calculation
        if (frameTimestamps.length > 30) {
          frameTimestamps.shift();
        }

        // Need at least 10 frames to calculate FPS
        if (frameTimestamps.length >= 10) {
          const timeElapsed = now - frameTimestamps[0];
          const frameCount = frameTimestamps.length - 1;
          if (timeElapsed > 0) {
            currentFPS = ((1000 * frameCount) / timeElapsed).toFixed(1);
            // Calculate how many frames equal 3 seconds
            framesForThreeSeconds = Math.ceil(currentFPS * TARGET_ALERT_TIME);
          }
        }
      }

      function getEAR(landmarks, indices) {
        const p1 = landmarks[indices[1]];
        const p2 = landmarks[indices[2]];
        const p3 = landmarks[indices[5]];
        const p4 = landmarks[indices[4]];
        const p0 = landmarks[indices[0]];
        const p5 = landmarks[indices[3]];

        const vertical1 = Math.hypot(p2.x - p4.x, p2.y - p4.y);
        const vertical2 = Math.hypot(p1.x - p3.x, p1.y - p3.y);
        const horizontal = Math.hypot(p0.x - p5.x, p0.y - p5.y);

        // Avoid division by zero
        if (horizontal === 0) return 1.0;
        return (vertical1 + vertical2) / (2.0 * horizontal);
      }

      // Get dynamic threshold based on user's normal eye state
      function getDynamicThreshold() {
        if (earHistory.length < EAR_HISTORY_SIZE) {
          return EAR_THRESHOLD; // Use default until we have enough data
        }

        // Sort EAR values and get the lower quartile as a baseline
        const sortedEAR = [...earHistory].sort((a, b) => a - b);
        const lowerQuartileIndex = Math.floor(sortedEAR.length * 0.25);
        const lowerQuartile = sortedEAR[lowerQuartileIndex];

        // Set threshold to 70% of the lower quartile
        return lowerQuartile * 0.7;
      }

      // Initialize MediaPipe Face Mesh
      async function initCamera() {
        // Hide permission overlay
        permissionOverlay.style.display = "none";

        // Set canvas size to match video
        canvas.width = video.width;
        canvas.height = video.height;

        // Update status
        status.textContent = "Starting camera...";

        try {
          const faceMesh = new FaceMesh({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            },
          });

          faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
          });

          faceMesh.onResults(onResults);

          // Start camera
          camera = new Camera(video, {
            onFrame: async () => {
              await faceMesh.send({ image: video });
            },
            width: 640,
            height: 480,
          });

          await camera.start();
          status.textContent = "Monitoring...";
        } catch (error) {
          console.error("Error starting camera:", error);
          status.textContent = "Camera error!";

          // Show Android specific error if running in WebView
          if (androidBridge.hasAndroidBridge) {
            androidError.style.display = "flex";
          }
        }
      }

      // Process results from Face Mesh
      function onResults(results) {
        // Update FPS
        updateFPS();

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw video frame on canvas (mirrored)
        ctx.save();
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(
          results.image,
          0,
          0,
          canvas.width,
          canvas.height
        );
        ctx.restore();

        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
          const landmarks = results.multiFaceLandmarks[0];

          // Draw face mesh
          drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {
            color: "#C0C0C070",
            lineWidth: 1,
          });

          // Left eye indices (adjusted for MediaPipe Face Mesh)
          const leftEyeIndices = [
            33, 160, 158, 133, 153, 144, // Upper eyelid
          ];

          // Right eye indices (adjusted for MediaPipe Face Mesh)
          const rightEyeIndices = [
            362, 385, 387, 263, 373, 380, // Upper eyelid
          ];

          // Calculate EAR for both eyes
          const leftEAR = getEAR(landmarks, leftEyeIndices);
          const rightEAR = getEAR(landmarks, rightEyeIndices);

          // Average EAR
          const ear = (leftEAR + rightEAR) / 2.0;

          // Add to history for dynamic threshold
          if (earHistory.length < EAR_HISTORY_SIZE) {
            earHistory.push(ear);
          } else {
            earHistory.shift();
            earHistory.push(ear);
          }

          // Get current threshold
          const currentThreshold = getDynamicThreshold();

          // Check if eyes are closed
          if (ear < currentThreshold) {
            consecutiveClosedFrames++;
            consecutiveOpenFrames = 0;
          } else {
            consecutiveOpenFrames++;
            if (consecutiveOpenFrames >= RECOVERY_FRAMES) {
              consecutiveClosedFrames = 0;
            }
          }

          // Update debug info
          debug.textContent = `EAR: ${ear.toFixed(2)} | FPS: ${currentFPS} | Threshold: ${currentThreshold.toFixed(
            2
          )} | Closed Frames: ${consecutiveClosedFrames}/${framesForThreeSeconds}`;

          // Check if alert should be triggered
          if (consecutiveClosedFrames >= framesForThreeSeconds) {
            if (!isAlertActive) {
              // Activate alert
              alertBox.style.display = "flex";
              alertSound.play();
              isAlertActive = true;

              // Send alert to App Inventor if available
              appInventorBridge.sendAlert(true);

              // Send SMS alert if phone number is available
              if (alertPhoneNumber) {
                sendSMSAlert();
              }

              // Send vibration if serial is connected
              if (writer) {
                sendVibration();
              }
            }
          } else if (isAlertActive && consecutiveOpenFrames >= RECOVERY_FRAMES) {
            // Deactivate alert
            alertBox.style.display = "none";
            isAlertActive = false;

            // Send alert state to App Inventor
            appInventorBridge.sendAlert(false);
          }

          // Draw eyes with color based on state
          const eyeColor = ear < currentThreshold ? "red" : "green";
          
          // Draw left eye
          drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, {
            color: eyeColor,
            lineWidth: 2,
          });
          
          // Draw right eye
          drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, {
            color: eyeColor,
            lineWidth: 2,
          });
        }
      }

      // Check Android permissions
      async function checkAndroidPermissions() {
        if (androidBridge.hasAndroidBridge) {
          const hasPermission = androidBridge.hasCameraPermission();
          if (!hasPermission) {
            const granted = androidBridge.requestCameraPermission();
            return granted;
          }
          return true;
        }
        return true; // Not on Android, assume permissions are OK
      }

      // Event listeners
      startButton.addEventListener("click", async () => {
        if (androidBridge.hasAndroidBridge) {
          const permissionsOK = await checkAndroidPermissions();
          if (permissionsOK) {
            initCamera();
          } else {
            status.textContent = "Camera permission denied";
            androidError.style.display = "flex";
          }
        } else {
          initCamera();
        }
      });

      retryButton.addEventListener("click", async () => {
        androidError.style.display = "none";
        const permissionsOK = await checkAndroidPermissions();
        if (permissionsOK) {
          initCamera();
        }
      });

      // Resize handler
      window.addEventListener("resize", () => {
        if (canvas) {
          canvas.width = video.width;
          canvas.height = video.height;
        }
      });
    </script>
  </body>
</html>
