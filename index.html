<!DOCTYPE html>
<html>
  <head>
    <title>Drowsiness Detection with SMS Alert</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: black;
        font-family: Arial, sans-serif;
      }

      .container {
        position: relative;
        width: 100%;
        height: 100%;
      }

      video,
      canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #status {
        position: absolute;
        top: 10px;
        left: 0;
        right: 0;
        text-align: center;
        padding: 10px;
        font-size: 24px;
        font-weight: bold;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        z-index: 10;
      }

      #alert {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 0, 0, 0.3);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 5;
      }

      #alert-text {
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 20px;
        border-radius: 10px;
        font-size: 30px;
        font-weight: bold;
      }

      #debug {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 5px;
        font-size: 14px;
        border-radius: 5px;
        z-index: 10;
      }

      #notification {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.5s;
      }

      #phone-container {
        position: absolute;
        top: 50px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px;
        border-radius: 5px;
        font-size: 14px;
        z-index: 10;
        width: 250px;
      }

      /* Permission overlay */
      #permission-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 20;
        color: white;
        text-align: center;
        padding: 20px;
        box-sizing: border-box;
      }

      #start-button {
        margin-top: 20px;
        padding: 15px 30px;
        background-color: #2196f3;
        color: white;
        border: none;
        border-radius: 5px;
        font-size: 18px;
        cursor: pointer;
        transition: background-color 0.3s;
        -webkit-tap-highlight-color: transparent;
      }

      #start-button:hover,
      #start-button:active {
        background-color: #0b7dda;
      }

      .permission-text {
        max-width: 90%;
        margin-bottom: 20px;
        font-size: 16px;
        line-height: 1.5;
      }

      /* Android specific error message */
      #android-error {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 30;
        color: white;
        text-align: center;
        padding: 20px;
        box-sizing: border-box;
      }

      /* Phone input form styles */
      .phone-form-title {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 16px;
        font-weight: bold;
      }

      .phone-input-group {
        display: flex;
        margin-bottom: 10px;
      }

      .country-code-input {
        width: 60px;
        padding: 8px;
        border: 1px solid #444;
        border-radius: 4px 0 0 4px;
        background-color: rgba(30, 30, 30, 0.8);
        color: white;
      }

      .phone-number-input {
        flex: 1;
        padding: 8px;
        border: 1px solid #444;
        border-radius: 0 4px 4px 0;
        background-color: rgba(30, 30, 30, 0.8);
        color: white;
      }

      .save-button {
        width: 100%;
        padding: 8px;
        background-color: #2196f3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s;
        -webkit-tap-highlight-color: transparent;
      }

      .save-button:hover,
      .save-button:active {
        background-color: #0b7dda;
      }

      .error-message {
        color: #ff6b6b;
        font-size: 12px;
        margin-top: 5px;
        display: none;
      }

      .current-phone {
        font-size: 12px;
        margin-top: 8px;
        color: #aaa;
      }

      /* Toggle for mesh visibility */
      #mesh-toggle-container {
        position: absolute;
        top: 50px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        z-index: 10;
      }

      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
        margin-left: 10px;
        vertical-align: middle;
      }

      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 24px;
      }

      .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
      }

      input:checked + .toggle-slider {
        background-color: #2196F3;
      }

      input:checked + .toggle-slider:before {
        transform: translateX(26px);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Permission overlay -->
      <div id="permission-overlay">
        <h2>Drowsiness Detection System</h2>
        <div class="permission-text">
          <p>
            This application uses your camera to detect drowsiness and can send
            alert messages when dangerous drowsiness is detected.
          </p>
          <p>
            We need your permission to access your camera for this safety
            feature to work.
          </p>
          <p>
            No video data is stored or transmitted - all processing happens
            locally in your browser.
          </p>
        </div>
        <button id="start-button">Start Camera & Begin Monitoring</button>
      </div>

      <!-- Android specific error message -->
      <div id="android-error">
        <h2>Camera Access Error</h2>
        <div class="permission-text">
          <p>Unable to access the camera. This may be due to:</p>
          <p>1. Camera permission not granted in Android settings</p>
          <p>2. Another app is currently using the camera</p>
          <p>3. WebView camera access is not enabled in the app</p>
        </div>
        <button id="retry-button">Retry Camera Access</button>
      </div>

      <video id="video" autoplay muted playsinline></video>
      <canvas id="output"></canvas>
      <div id="status">Waiting for camera permission...</div>
      <div id="alert"><div id="alert-text">EYES CLOSED TOO LONG!</div></div>
      <div id="debug">EAR: 0.00 | FPS: 0 | State: Not Started</div>
      <div id="notification">SMS Alert: Inactive</div>
      
      <!-- Mesh visibility toggle -->
      <div id="mesh-toggle-container">
        Face Mesh:
        <label class="toggle-switch">
          <input type="checkbox" id="mesh-toggle" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      
      <!-- Phone input form -->
      <div id="phone-container">
        <h3 class="phone-form-title">Alert Phone Number</h3>
        <div class="phone-input-group">
          <input
            type="text"
            id="country-code"
            class="country-code-input"
            placeholder="+1"
            maxlength="4"
          />
          <input
            type="tel"
            id="phone-number"
            class="phone-number-input"
            placeholder="Phone number"
          />
        </div>
        <div id="error-message" class="error-message">
          Please enter a valid country code and phone number
        </div>
        <button id="save-phone" class="save-button">Save</button>
        <div id="current-phone" class="current-phone">Current: +66887513078</div>
      </div>
    </div>

    <audio id="alertSound" src="alert.mp3"></audio>

    <script>
      // Flag to track if running from MIT App Inventor
      let isRunningFromMIT = false;

      // Function to be called from MIT App Inventor to indicate the environment
      function runfrommit() {
        isRunningFromMIT = true;
        console.log("Running from MIT App Inventor environment");
        showNotification("MIT App Inventor detected");

        // Automatically initialize camera when running from MIT
        if (androidBridge.hasAndroidBridge) {
          // If we have Android bridge, we need to check permissions
          checkAndroidPermissions().then((permissionsOK) => {
            if (permissionsOK) {
              initCamera();
            }
          });
        } else {
          // No Android bridge, directly initialize camera
          initCamera();
        }

        // Send acknowledgment to App Inventor if WebViewString is available
        if (window.AppInventor && window.AppInventor.setWebViewString) {
          window.AppInventor.setWebViewString("MIT_ENVIRONMENT=ACKNOWLEDGED");
        }

        return true; // Return true to confirm successful execution
      }

      // Make runfrommit globally available
      window.runfrommit = runfrommit;

      // Android WebView Bridge
      function AndroidBridge() {
        this.hasAndroidBridge = typeof Android !== "undefined";

        this.requestCameraPermission = function () {
          if (this.hasAndroidBridge && Android.requestCameraPermission) {
            return Android.requestCameraPermission();
          }
          return true; // Return true if no Android bridge (regular browser)
        };

        this.hasCameraPermission = function () {
          if (this.hasAndroidBridge && Android.hasCameraPermission) {
            return Android.hasCameraPermission();
          }
          return true; // Return true if no Android bridge (regular browser)
        };

        this.showToast = function (message) {
          if (this.hasAndroidBridge && Android.showToast) {
            Android.showToast(message);
          } else {
            console.log("Toast (not on Android):", message);
          }
        };
      }

      const androidBridge = new AndroidBridge();

      // Elements
      const video = document.getElementById("video");
      const canvas = document.getElementById("output");
      const ctx = canvas.getContext("2d");
      const status = document.getElementById("status");
      const alertBox = document.getElementById("alert");
      const alertSound = document.getElementById("alertSound");
      const debug = document.getElementById("debug");
      const notification = document.getElementById("notification");
      const phoneContainer = document.getElementById("phone-container");
      const permissionOverlay = document.getElementById("permission-overlay");
      const startButton = document.getElementById("start-button");
      const androidError = document.getElementById("android-error");
      const retryButton = document.getElementById("retry-button");
      const currentPhoneDisplay = document.getElementById("current-phone");
      const meshToggle = document.getElementById("mesh-toggle");

      // Phone input elements
      const countryCodeInput = document.getElementById("country-code");
      const phoneNumberInput = document.getElementById("phone-number");
      const saveButton = document.getElementById("save-phone");
      const errorMessage = document.getElementById("error-message");

      // Mesh visibility settings
      let showMesh = true;
      let meshOpacity = 1.0;
      let meshLineWidth = 1.5;
      let eyeLineWidth = 3;

      // Adjusted threshold for more accurate eye closure detection
      const EAR_THRESHOLD = 0.07; // Updated threshold as requested by user
      const TARGET_ALERT_TIME = 3; // Alert after 3 seconds of eyes closed
      const RECOVERY_FRAMES = 3; // Number of open frames needed to reset alert
      const SMS_COOLDOWN_TIME = 15000; // 15 seconds cooldown for SMS alerts

      // SMS Configuration using API key instead of Account SID/Auth Token
      const twilioApiKey = "SK361e6faad3ec68d3c14e0b925c3dde47";
      const twilioApiSecret = "oAZyaPgsFF7oEzbVT1hRktGuiIu9wWL1";
      const twilioAccountSid = "AC7de93db1c7917508d40746d5c34a0f1e"; // Still need account SID for URL
      const twilioFromNumber = "+18166246916";
      let alertPhoneNumber = "+66887513078"; // Default phone number
      const alertMessage = "Drowsy Detect SMS Direct to this number";

      // Track last SMS sent time
      let lastSMSSentTime = 0;
      let camera = null;

      // Initialize mesh toggle
      function initMeshToggle() {
        meshToggle.addEventListener('change', function() {
          showMesh = this.checked;
          showNotification("Face mesh " + (showMesh ? "enabled" : "disabled"));
        });
      }

      // Initialize phone input form
      function initPhoneForm() {
        // Set initial value in the display
        currentPhoneDisplay.textContent = "Current: " + alertPhoneNumber;
        
        // Auto-add + to country code if user doesn't type it
        countryCodeInput.addEventListener('input', function() {
          if (this.value && !this.value.startsWith('+')) {
            this.value = '+' + this.value;
          }
          
          // Only allow numbers and + sign
          this.value = this.value.replace(/[^\d+]/g, '');
        });

        // Only allow numbers in phone input
        phoneNumberInput.addEventListener('input', function() {
          this.value = this.value.replace(/\D/g, '');
        });

        // Handle Enter key press in phone number field
        phoneNumberInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            saveButton.click();
          }
        });

        // Save button click handler
        saveButton.addEventListener('click', function() {
          const countryCode = countryCodeInput.value.trim();
          const phoneNumber = phoneNumberInput.value.trim();
          
          // Validate inputs
          if (!countryCode || !phoneNumber || !countryCode.startsWith('+') || countryCode.length < 2 || phoneNumber.length < 5) {
            errorMessage.style.display = 'block';
            return;
          }
          
          // Hide error message if validation passes
          errorMessage.style.display = 'none';
          
          // Combine country code and phone number
          const fullPhoneNumber = countryCode + phoneNumber;
          
          // Call the receivePhoneNumber function
          receivePhoneNumber(fullPhoneNumber);
          
          // Show success feedback
          saveButton.textContent = 'Saved!';
          setTimeout(() => {
            saveButton.textContent = 'Save';
          }, 2000);
        });
      }

      // Function to receive phone number from external source
      function receivePhoneNumber(phoneNumber) {
        console.log("Received phone number: " + phoneNumber);
        // Update the alert phone number
        alertPhoneNumber = phoneNumber;
        // Display it in the UI
        currentPhoneDisplay.textContent = "Current: " + phoneNumber;
        // Show notification
        showNotification("Alert phone number updated: " + phoneNumber);

        // Show toast on Android if available
        androidBridge.showToast("Alert phone updated: " + phoneNumber);
      }

      // Make the function globally available
      window.receivePhoneNumber = receivePhoneNumber;

      // FPS calculation
      let frameTimestamps = [];
      let currentFPS = 0;
      let framesForThreeSeconds = 30; // Initial guess, will be adjusted based on actual FPS

      let consecutiveClosedFrames = 0;
      let consecutiveOpenFrames = 0;
      let isAlertActive = false;
      let earHistory = [];
      const EAR_HISTORY_SIZE = 30; // Track EAR values to establish baseline

      const appInventorBridge = {
        sendAlert: function (isActive) {
          if (window.AppInventor && window.AppInventor.setWebViewString) {
            window.AppInventor.setWebViewString(
              "ALERT_STATE=" + (isActive ? "ACTIVE" : "INACTIVE")
            );
          }
        },
      };

      // Function to send SMS alert with Twilio using API keys
      function sendSMSAlert() {
        const currentTime = Date.now();

        // Check cooldown period
        if (currentTime - lastSMSSentTime < SMS_COOLDOWN_TIME) {
          const remainingCooldown = Math.ceil(
            (SMS_COOLDOWN_TIME - (currentTime - lastSMSSentTime)) / 1000
          );
          showNotification(`SMS cooldown: ${remainingCooldown}s remaining`);
          return;
        }

        // Update last sent time
        lastSMSSentTime = currentTime;

        showNotification(`Sending SMS alert to ${alertPhoneNumber}...`);

        // Android toast if available
        androidBridge.showToast("Sending SMS alert...");

        // Prepare data for the POST request
        const url = `https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`;
        const data = new URLSearchParams();
        data.append("From", twilioFromNumber);
        data.append("To", alertPhoneNumber);
        data.append("Body", alertMessage);

        // Send the POST request to Twilio API with API Key authentication
        fetch(url, {
          method: "POST",
          body: data,
          headers: {
            Authorization:
              "Basic " + btoa(twilioApiKey + ":" + twilioApiSecret),
            "Content-Type": "application/x-www-form-urlencoded",
          },
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error_code) {
              showNotification(`SMS Error: ${data.message}`);
              console.error("Error sending SMS:", data.message);
              androidBridge.showToast("SMS Error: " + data.message);
            } else {
              showNotification("SMS alert sent successfully!");
              console.log("SMS sent successfully:", data.sid);
              androidBridge.showToast("SMS alert sent successfully!");
            }
          })
          .catch((error) => {
            showNotification("Failed to send SMS alert");
            console.error("Error sending SMS:", error);
            androidBridge.showToast("Failed to send SMS alert");
          });
      }

      // Show notification with auto-hide
      function showNotification(message) {
        notification.textContent = message;
        notification.style.opacity = 1;

        // Hide notification after 3 seconds
        setTimeout(() => {
          notification.style.opacity = 0;
        }, 3000);
      }

      // Calculate FPS based on recent frame timestamps
      function updateFPS() {
        const now = performance.now();
        frameTimestamps.push(now);

        // Keep only the last 30 frames for FPS calculation
        if (frameTimestamps.length > 30) {
          frameTimestamps.shift();
        }

        // Need at least 10 frames to calculate FPS
        if (frameTimestamps.length >= 10) {
          const timeElapsed = now - frameTimestamps[0];
          const frameCount = frameTimestamps.length - 1;
          if (timeElapsed > 0) {
            currentFPS = ((1000 * frameCount) / timeElapsed).toFixed(1);
            // Calculate how many frames equal 3 seconds
            framesForThreeSeconds = Math.ceil(currentFPS * TARGET_ALERT_TIME);
          }
        }
      }

      function getEAR(landmarks, indices) {
        const p1 = landmarks[indices[1]];
        const p2 = landmarks[indices[2]];
        const p3 = landmarks[indices[5]];
        const p4 = landmarks[indices[4]];
        const p0 = landmarks[indices[0]];
        const p5 = landmarks[indices[3]];

        const vertical1 = Math.hypot(p2.x - p4.x, p2.y - p4.y);
        const vertical2 = Math.hypot(p1.x - p3.x, p1.y - p3.y);
        const horizontal = Math.hypot(p0.x - p5.x, p0.y - p5.y);

        // Avoid division by zero
        if (horizontal === 0) return 1.0;
        return (vertical1 + vertical2) / (2.0 * horizontal);
      }

      // Get dynamic threshold based on user's normal eye state
      function getDynamicThreshold() {
        if (earHistory.length < EAR_HISTORY_SIZE) {
          return EAR_THRESHOLD; // Use default until we have enough data
        }

        // Sort and get the lower quartile as the threshold
        const sortedEAR = [...earHistory].sort((a, b) => a - b);
        const lowerQuartileIndex = Math.floor(sortedEAR.length * 0.25);
        const dynamicThreshold = sortedEAR[lowerQuartileIndex] * 0.85; // 15% below lower quartile

        return Math.min(dynamicThreshold, EAR_THRESHOLD); // Don't go higher than default
      }

      function resizeCanvas() {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
      }

      function onResults(results) {
        updateFPS(); // Update FPS on each frame

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
          // Get the first face
          const landmarks = results.multiFaceLandmarks[0];

          // Left eye indices (simplified)
          const leftEyeIndices = [33, 160, 158, 133, 153, 144];
          // Right eye indices (simplified)
          const rightEyeIndices = [362, 385, 387, 263, 373, 380];

          // Calculate EAR for both eyes
          const leftEAR = getEAR(landmarks, leftEyeIndices);
          const rightEAR = getEAR(landmarks, rightEyeIndices);
          const avgEAR = (leftEAR + rightEAR) / 2.0;

          // Add to history for dynamic threshold
          if (earHistory.length >= EAR_HISTORY_SIZE) {
            earHistory.shift();
          }
          earHistory.push(avgEAR);

          // Get current threshold
          const currentThreshold = getDynamicThreshold();

          // Update debug info
          debug.textContent = `EAR: ${avgEAR.toFixed(2)} | FPS: ${currentFPS} | Threshold: ${currentThreshold.toFixed(
            2
          )} | Frames: ${consecutiveClosedFrames}/${framesForThreeSeconds}`;

          // Check if eyes are closed
          if (avgEAR < currentThreshold) {
            consecutiveClosedFrames++;
            consecutiveOpenFrames = 0;

            // Check if eyes have been closed for too long
            if (
              consecutiveClosedFrames >= framesForThreeSeconds &&
              !isAlertActive
            ) {
              // Trigger alert
              isAlertActive = true;
              alertBox.style.display = "flex";
              status.textContent = "ALERT: Eyes Closed Too Long!";
              status.style.backgroundColor = "rgba(255, 0, 0, 0.7)";

              // Play alert sound
              alertSound.play().catch((e) => {
                console.error("Error playing alert sound:", e);
              });

              // Send SMS alert
              sendSMSAlert();

              // Send alert to App Inventor if running from MIT
              appInventorBridge.sendAlert(true);
            }
          } else {
            // Eyes are open
            consecutiveOpenFrames++;
            if (consecutiveOpenFrames >= RECOVERY_FRAMES) {
              consecutiveClosedFrames = 0;
            }

            // Reset alert if it was active
            if (isAlertActive && consecutiveOpenFrames >= RECOVERY_FRAMES) {
              isAlertActive = false;
              alertBox.style.display = "none";
              status.textContent = "Monitoring...";
              status.style.backgroundColor = "rgba(0, 0, 0, 0.5)";

              // Send alert state to App Inventor
              appInventorBridge.sendAlert(false);
            }
          }

          // Draw face mesh if enabled
          if (showMesh) {
            // Draw full face mesh with improved visibility
            drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {
              color: `rgba(180, 180, 255, ${meshOpacity})`,
              lineWidth: meshLineWidth,
            });
            
            // Draw face contour for better visibility
            drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, {
              color: `rgba(255, 255, 255, ${meshOpacity})`,
              lineWidth: meshLineWidth + 0.5,
            });
            
            // Draw lips for better visibility
            drawConnectors(ctx, landmarks, FACEMESH_LIPS, {
              color: `rgba(255, 150, 150, ${meshOpacity})`,
              lineWidth: meshLineWidth + 0.5,
            });
            
            // Draw eyes with color indicating open/closed state
            drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, {
              color: rightEAR < currentThreshold ? "#FF3030" : "#30FF30",
              lineWidth: eyeLineWidth,
            });
            drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, {
              color: leftEAR < currentThreshold ? "#FF3030" : "#30FF30",
              lineWidth: eyeLineWidth,
            });
            
            // Draw eyebrows for better visibility
            drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYEBROW, {
              color: `rgba(255, 230, 150, ${meshOpacity})`,
              lineWidth: meshLineWidth + 0.5,
            });
            drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYEBROW, {
              color: `rgba(255, 230, 150, ${meshOpacity})`,
              lineWidth: meshLineWidth + 0.5,
            });
          }
        } else {
          // No face detected
          status.textContent = "No face detected";
        }
      }

      // Check Android permissions
      async function checkAndroidPermissions() {
        if (androidBridge.hasAndroidBridge) {
          // Check if we have camera permission
          if (!androidBridge.hasCameraPermission()) {
            // Request camera permission
            const permissionGranted = androidBridge.requestCameraPermission();
            if (!permissionGranted) {
              // Show Android error
              androidError.style.display = "flex";
              return false;
            }
          }
        }
        return true;
      }

      // Initialize camera
      function initCamera() {
        permissionOverlay.style.display = "none";
        status.textContent = "Starting camera...";

        const faceMesh = new FaceMesh({
          locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
          },
        });

        faceMesh.setOptions({
          maxNumFaces: 1,
          refineLandmarks: true,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        faceMesh.onResults(onResults);

        camera = new Camera(video, {
          onFrame: async () => {
            await faceMesh.send({ image: video });
          },
          width: 640,
          height: 480,
        });

        camera
          .start()
          .then(() => {
            console.log("Camera started successfully");
            status.textContent = "Monitoring...";
            resizeCanvas();
            showNotification("Face mesh enabled with eye threshold: 0.07");
          })
          .catch((error) => {
            console.error("Error starting camera:", error);
            status.textContent = "Camera error: " + error.message;

            // Show Android error if appropriate
            if (androidBridge.hasAndroidBridge) {
              androidError.style.display = "flex";
            }
          });
      }

      // Start button click handler
      startButton.addEventListener("click", () => {
        checkAndroidPermissions().then((permissionsOK) => {
          if (permissionsOK) {
            initCamera();
          }
        });
      });

      // Retry button click handler
      retryButton.addEventListener("click", () => {
        androidError.style.display = "none";
        checkAndroidPermissions().then((permissionsOK) => {
          if (permissionsOK) {
            initCamera();
          }
        });
      });

      // Handle window resize
      window.addEventListener("resize", resizeCanvas);

      // Initialize phone form and mesh toggle when document is loaded
      document.addEventListener('DOMContentLoaded', function() {
        initPhoneForm();
        initMeshToggle();
      });

      // Initialize immediately in case DOMContentLoaded already fired
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        initPhoneForm();
        initMeshToggle();
      }
    </script>
  </body>
</html>
